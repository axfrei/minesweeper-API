package com.deviget.minesweeper.model;

import java.util.ArrayList;
import java.util.Date;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import com.amazonaws.services.dynamodbv2.datamodeling.DynamoDBAttribute;
import com.amazonaws.services.dynamodbv2.datamodeling.DynamoDBAutoGenerateStrategy;
import com.amazonaws.services.dynamodbv2.datamodeling.DynamoDBAutoGeneratedKey;
import com.amazonaws.services.dynamodbv2.datamodeling.DynamoDBAutoGeneratedTimestamp;
import com.amazonaws.services.dynamodbv2.datamodeling.DynamoDBHashKey;
import com.amazonaws.services.dynamodbv2.datamodeling.DynamoDBMapperFieldModel.DynamoDBAttributeType;
import com.amazonaws.services.dynamodbv2.datamodeling.DynamoDBTable;
import com.amazonaws.services.dynamodbv2.datamodeling.DynamoDBTyped;
import com.deviget.minesweeper.error.MinesweeperApiException;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;

@DynamoDBTable(tableName = "Games")
@Data
@AllArgsConstructor
@Builder
public class Game {

    @DynamoDBAutoGeneratedKey
    @DynamoDBHashKey(attributeName = "id")
    private String id;

    @DynamoDBAttribute(attributeName = "user")
    private User user;

    @DynamoDBAttribute(attributeName = "cells")
    private List<Cell> cells;

    @DynamoDBTyped(DynamoDBAttributeType.S)
    @DynamoDBAttribute(attributeName = "status")
    private GameStatus status;

    @DynamoDBAttribute(attributeName = "creationTime")
    @DynamoDBAutoGeneratedTimestamp(strategy = DynamoDBAutoGenerateStrategy.CREATE)
    private Date creationTime;

    @DynamoDBAttribute(attributeName = "lastUpdate")
    @DynamoDBAutoGeneratedTimestamp(strategy = DynamoDBAutoGenerateStrategy.ALWAYS)
    private Date lastUpdate;

    public Game() {
    }

    public Game initCells(int columns, int rows, int bombs) {

       

        if(columns*rows <= bombs){
            throw new MinesweeperApiException("Invalid request. Amount of bombs should be less than total amount of cells");
        }

        //lets distribute the bombs randomly
        Set<Integer> bombDistribution = new HashSet<Integer>();
        while (bombDistribution.size() < bombs){
            bombDistribution.add((int) (Math.random() * ((rows * columns)-1)));
        }

        this.cells = new ArrayList<Cell>();
        // lets create cells
        for (int r = 0; r < rows; r++) {
            for (int c = 0; c < columns; c++) {
                cells.add(Cell.builder().x(r).y(c).bomb(bombDistribution.contains((r*rows)+c)).build());
            }
        }

        // lets calculate the value for each cell
        cells.stream().map(cellToInit -> {
            int value = getAdjacentCellsStream(cellToInit).map(c -> c.isBomb() ? 1 : 0).reduce(0, Integer::sum);
            cellToInit.setValue(value);
            return cellToInit;
        }).collect(Collectors.toList());

        return this;
    }

    public Stream<Cell> getAdjacentCellsStream(Cell cell) {
        return cells.stream().filter(c -> c.isAdjacentTo(cell));
    }

    public void pause() {
        this.setStatus(this.status.pause());
    }

    public Game recognizeCell(Cell cell) {
        if (cell.isBomb()) {
            // game over
            this.setStatus(GameStatus.GAME_OVER);
            return this;
        }

        cell.setRecognized(true);
        if (cell.getValue() == 0) {
            this.recognizeAdjacentCells(cell);
        }

        int totalRecognized = cells.stream().map(c -> c.isRecognized() ? 1 : 0).reduce(0, Integer::sum);
        int totalBombs = getBombs();

        if (totalRecognized + totalBombs == cells.size()) {
            this.setStatus(GameStatus.WIN);
        }

        return this;
    }

    public void recognizeAdjacentCells(Cell aCell) {
        getAdjacentCellsStream(aCell).filter(adjCell -> adjCell.getValue() == 0 && !adjCell.isRecognized() && !adjCell.isBomb())
        .forEach(adjEmptyCell -> {
            adjEmptyCell.setRecognized(true);
            recognizeAdjacentCells(adjEmptyCell);
        });
    }

    public Integer getBombs() {
        return cells.stream().map(c -> c.isBomb() ? 1 : 0).reduce(0, Integer::sum);
    }

    public Cell getCell(int x, int y) {
        return cells.stream().filter(c -> c.getX() == x && c.getY() == y).findFirst()
                .orElseThrow(() -> new MinesweeperApiException("Requested cell is out of index"));
    }
}