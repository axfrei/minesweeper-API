package com.deviget.minesweeper.model;

import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.Random;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import com.amazonaws.services.dynamodbv2.datamodeling.DynamoDBAttribute;
import com.amazonaws.services.dynamodbv2.datamodeling.DynamoDBAutoGenerateStrategy;
import com.amazonaws.services.dynamodbv2.datamodeling.DynamoDBAutoGeneratedKey;
import com.amazonaws.services.dynamodbv2.datamodeling.DynamoDBAutoGeneratedTimestamp;
import com.amazonaws.services.dynamodbv2.datamodeling.DynamoDBHashKey;
import com.amazonaws.services.dynamodbv2.datamodeling.DynamoDBTable;

import lombok.Builder;
import lombok.Data;

@DynamoDBTable(tableName = "Games")
@Data
@Builder
public class Game {
    
    @DynamoDBAutoGeneratedKey
    @DynamoDBHashKey(attributeName = "id")
    private String id;

    @DynamoDBAttribute(attributeName = "user")
    private User user;
    
    @DynamoDBAttribute(attributeName = "cells")
    private List<Cell> cells;

    @DynamoDBAttribute(attributeName = "status")
    private String status;

    @DynamoDBAttribute(attributeName = "creationTime")
    @DynamoDBAutoGeneratedTimestamp(strategy=DynamoDBAutoGenerateStrategy.CREATE)
    private Date creationTime;
    
    @DynamoDBAttribute(attributeName = "lastUpdate")
    @DynamoDBAutoGeneratedTimestamp(strategy=DynamoDBAutoGenerateStrategy.ALWAYS)
    private Date lastUpdate;


    public Game initCells(int columns, int rows, int bombs) {

            this.cells = new ArrayList<Cell>();
            Random random = new Random();
            for (int r = 0; r <rows; r++) {
                for (int c = 0; c <columns; c++) {
                    cells.add(Cell.builder().x(r).y(c).bomb(random.nextBoolean() && (bombs-- > 0) ).build());
                }
            }

            cells.stream().map(cToFill -> {
                int value = getAdyacentCellsStream(cToFill).map(c -> c.isBomb()? 1:0).reduce(0,Integer::sum);
                cToFill.setValue(value);
                return cToFill;
            }).collect(Collectors.toList());

		return this;
	}


    private Stream<Cell> getAdyacentCellsStream(Cell cell) {
        return cells.stream().filter(c ->
            (c.getX()-cell.getX() == -1 &&  c.getY()-cell.getY() == -1) ||
            (c.getX()-cell.getX() == -1 &&  c.getY()-cell.getY() == 0) ||
            (c.getX()-cell.getX() == -1 &&  c.getY()-cell.getY() == 1) ||
            (c.getX()-cell.getX() == 0 &&  c.getY()-cell.getY() == -1) ||
            (c.getX()-cell.getX() == 0 &&  c.getY()-cell.getY() == 1) ||
            (c.getX()-cell.getX() == 1 &&  c.getY()-cell.getY() == -1) ||
            (c.getX()-cell.getX() == 1 &&  c.getY()-cell.getY() == 0) ||
            (c.getX()-cell.getX() == 1 &&  c.getY()-cell.getY() == 1)
            );
    }
}
